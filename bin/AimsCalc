#!/usr/bin/env ruby

#
# AimsCalc [geometry] [control]
# 
# Author: Joshua Shapiro, 2012
# email: joshua.shapiro@gmail.com
# 
# Generate a set of FHI-AIMS calculations from control and geometry files.
# If the user provides filename on the command line the calculation is generated, 
# otherwise, the user is prompted for filenames.
#

begin
  require 'aims_project'
rescue
  require 'rubygems'
  require 'aims_project'
end

def usage
  STDERR.puts <<-END_USAGE
usage: AimsCalc command [args]
  Valid commands are:
  create     - Create a new calculation
  restart    - Restart an aborted or cancelled calculation using most recent geometry 
  rerun      - Rerun a calculation using the original geometry and control  
  invalidate - Invalidate a geometry or control file and dependent calculations 
  help cmd - For help on a given command
END_USAGE
end

def help(cmd)
  case cmd
  when /create/
    puts <<-HELP
usage: AimsCalc create [geometry] [control]
Create and stage a new calculation.
 * geometry is the name of a geometry file
 * control is the name of a control file
 
 Without arguments, the user will be prompted to select geometry and control files.
 
HELP
  when /restart/
    puts <<-HELP
usage: AimsCalc restart [calculation]
Restart an aborted or cancelled calculation using most recent available geometry.
 * The name of a calculation
 
Without arguments, the user will be prompted to select a calculation.

HELP
  when /status/
    puts <<-HELP
usage: AimsCalc status
Currently just dumps all the status files
HELP
  when /rerun/
    puts <<-HELP

usage: AimsCalc rerun [calculation]

Use this to rerun a calculation for whatever reason.  This will 
set the calculation status back to staged. run cap aims:enqueue to 
actually rerun the calculation.
HELP
  when /invalidate/
    puts <<-HELP
    
usage: AimsCalc invalidate [geometry or control]

Invalidate a geometry or control file.  This will mark the geometry
or control file as well as any dependent calculations as INVALID.  
A warning will be issued if the user tries to use the INVALID input file.
HELP
  else
    usage
  end
end


# Create a calculation from a geometry and control file. 
# @param [String] geometry The name of a file that can be found in the geometry directory
# @param [String] control The name of a file that can be found in the control directory
# @param [Array<String>] args An array of string key-value pairs in the form of "key=value"
#        These key-value pairs will be loaded as instance variables into the binding that
#        is used to evaluate geometry and control.
def build_calculation(geometry, control, args)
  begin
    vars = {}
    
    # Condition format of input user variables
    args.each{|arg| 
      if arg =~ /(.*)=(.*)/
        symbol = $1
        value = $2
        # Prefix with an @
        sym = if symbol.to_s =~ /^@.*/
          symbol.to_sym
        else
          ("@" + symbol.to_s).to_sym
        end
        
        # Cast value to Float if applicable
        val = if value =~ /^(\d+\.*\d*)$/
          $1.to_f
        elsif value =~ /"(.*)"/ or value =~ /'(.*)'/
          $1
        else
          value
        end
        
        vars[sym] = val
      end
    }
    calc = AimsProject::Calculation.create(geometry, control, vars)
    puts "Created #{calc.calculation_directory}"
  rescue 
    puts $!.message
  end
end

# Generate a new calculation by calling Calculation::restart_relaxation
def restart_calculation(calculation)
  calc_dir = File.join(AimsProject::CALCULATION_DIR, File.basename(calculation))
  calc = AimsProject::Calculation.load(calc_dir)
  newcalc = calc.restart_relaxation
  puts "Created #{newcalc.name}"
end

# Print status information of each calculation
def calc_statuses
  project_obj_files = Dir["*.yaml"]
  project = AimsProject::Project.load(project_obj_files.first)
  project.calculations.each{|c|
      puts c.to_yaml
  }
end

# Set the calculation status back to staged
def rerun_calculation(calculation)
  calc_dir = File.join(AimsProject::CALCULATION_DIR, File.basename(calculation))
  calc = AimsProject::Calculation.load(calc_dir)
  calc.status = AimsProject::STAGED
  calc.save
  puts "Calculation status set to STAGED. Run cap aims:enqueue to execute."
  puts
end

# Invalidate each of the geometry or control inputs specified in arguments
def invalidate(args)
  args.each {|arg|
    files =  Dir.glob(File.join(AimsProject::GEOMETRY_DIR, arg))
    files += Dir.glob(File.join(AimsProject::CONTROL_DIR, arg))
    files.each{|f|
      # Write a note in file header
      puts "I would invalidate #{f} here if I was implemented..."
      # Find all the dependent calculations
      
      # and set their status to invalid
      
    }
  }
end

# Run the desired command
begin
  args = ARGV
  cmd = args.shift
  case cmd
  when /create/
    build_calculation(args[0], args[1], args[2..-1])
  when /restart/
    restart_calculation(args[0])
  when /status/
    calc_statuses
  when /rerun/
    rerun_calculation(args[0])
  when /invalidate/
    invalidate(args)
  when /help/
    help(args[0])
  else
    usage
  end
rescue AimsProject::AimsProjectException => ex
  STDERR.puts ex.message
rescue => error
  STDERR.puts
  STDERR.puts "Sorry, something went wrong. Please send the following information to joshua.shapiro@gmail.com"
  STDERR.puts
  STDERR.puts "FILE:  #{__FILE__}"
  STDERR.puts "CMD:   #{cmd}"
  STDERR.puts "ARGS:  #{args.join(" ")}"
  STDERR.puts "ERROR: " + error.message
  STDERR.print "\t" + error.backtrace.slice(0..5).join("\n\t")
  STDERR.puts 
  STDERR.puts 
end